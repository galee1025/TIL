# var, let, const 기본적 차이
### var의 문제점

1. 변수 중복 선언 가능 : 실수로 같은 이름의 변수를 다시 선언했을 때 먼저 선언한 변수 값이 변경
2. **함수 레벨 스코프** : 전역 변수로 선언한 var를 코드 블록 내에서 똑같이 선언했을 때 전역 변수 값을 변경하게 된다. 전역 변수를 남발하게 되고 중복 선언 된다.
3. **변수 호이스팅** : 변수 선언 전에 참조 가능. 할당문 이전에 참조하면 undefined 반환. 에러는 생기지 않지만 가독성을 떨어뜨리고 오류 발생의 여지를 남긴다.
런타임 이전에 암묵적으로 ‘선언’과 ‘초기화’가 한번에 진행된다. 또한 암묵적 전역, 전역 객체 window의 프로퍼티가 된다. 전역 객체 프로퍼티 참조에서 window는 생략될 수 있다.

 var의 단점 보완을 위해 ES6에서 새로운 변수 선언 키워드 let과 const를 도입
<br>
<br>

### let

1. 변수 중복 선언 금지 - 같은 스코프 내 중복 선언하면 SyntaxError가 나온다! 이미 정의 된 식별자
2. **블록 레벨 스코프** - 전역 변수를 코드 블록 내에서 불러올 수 있지만, 코드 블록 내 지역 변수는 전역에서 참조할 수 없다.
3. **변수 호이스팅** - 호이스팅이 발생하지 **않는 것처럼** 동작한다. 참조 에러 ReferenceError 발생
’선언’과 ‘초기화’가 분리되어 진행(런타임 이전에 선언, 초기화는 변수 선언문에 도달했을 때 실행)

자바스크립트 ES6에서 도입된 모든 선언(var, let, const, function, class 등)은 호이스팅한다.

단, let const class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.
<br>
<br>

### const

상수 선언을 위해 사용한다(반드시는 아님)

1. 선언과 초기화 : 반드시 선언과 동시에 초기화해야 한다.(반드시 초기값 할당) 그렇지 않으면 문법 에러 발생
2. **블록 레벨 스코프**
3. **변수 호이스팅** - 호이스팅이 발생하지 않는 것처럼 동작.
4. 재할당 금지 (객체를 할당한 경우 재할당 없이도 직접 변경이 가능해 값 변경이 가능)
5. 상수
원시 값을 할당한 경우 변수 값 변경 불가능. 이런 특징으로 상수를 표현하는 데 사용한다. 변수의 상대 개념.

<br>
<br>
<br>

# SCSS/Styled-Components 차이, 장단점

### Sass(SCSS)
- css in css, js 파일과 분리되어 있다.
- 컴포넌트의 상태값이 변화하더라도 반응이 쉽지 않다.
- 브라우저에 보여지지 않는 컴포넌트까지 읽기 때문에 불필요한 컴파일 과정이 추가된다.
<br>

### styled-components
- css in js, 컴포넌트가 렌더링 될 때만 스타일 정보를 읽어온다.
- 동적인 이벤트가 많은 사이트라면 스타일 정보도 다시 읽어와야 하기 때문에 빠른 페이지 로드에 불리하다.

<br>
<br>
<br>

# JWT

**JWT : JSON Web Token**
클라이언트와 서버, 서비스와 서비스 통신 시 권한 인가(Authorization)를 위해 사용하는 토큰

<br>
<br>
<br>

# 브라우저의 작동원리
브라우저는 동기적으로 HTML, CSS, Javascript를 처리한다. 
HTML, CSS 파일은 렌더링 엔진의 각 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다. 
이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 표시한다. 
자바스크립트는 자바스크립트 엔진이 처리하기 때문에 HTML 파서가 파싱 도중 
script 태그를 만나면 DOM 생성을 멈추고 권한을 자바스크립트 엔진에게 넘긴다. 
그래서 블로킹이 발생할 수 있기 때문에 script 태그의 위치는 body 태그 아래 위치 시키는 것이 좋다.

<br>
<br>
<br>

# 로컬, 세션 스토리지, 쿠키
**쿠키**
일시적으로 필요한 가벼운 데이터 저장 (팝업창, 로그인 자동 완성)
서버가 생성해 전달해준 뒤, 브라우저에 저장하고 요청시 HTTP header에 쿠키를 담아 전송한다. 
대부분의 브라우저가 지원하며 데이터 유효기간 지정이 가능하다.

**웹 스토리지**
HTML5에서 나온 새로운 방식의 데이터 저장소. 
쿠키보다 큰 저장 용량을 가지고 있어 많은 양의 데이터를 로컬에 저장할 수 있다. (최소 5MB) 
정보가 서버로 전송되지 않기 때문에 트래픽 낭비를 줄일 수 있다.
단점으로는 HTML5를 지원하는 브라우저만 사용 가능하며, 
로컬 스토리지에 접근하는 js 코드로 쉽게 접근이 가능해 XSS로부터 위험하다.
두 스토리지 객체는 Map과 유사하지만 인덱스를 이용해 키에 접근할 수 있다는 점에서 Map과 차이가 있다. 
동기적으로 작동하고 문자열

- **로컬 스토리지**
지속적으로 필요한 데이터 저장 (자동 로그인)
데이터 영구 저장이 가능하다.

- **세션 스토리지**

일시적으로 필요한 데이터 저장 (일회성 로그인, 비로그인 장바구니)
브라우저가 닫히면 스토리지가 초기화된다.

**IndexedDB**

브라우저에서 제공하는 데이터베이스. 
웹 스토리지에 저장하기에는 많은 양의 데이터를 저장할 때 주로 쓰인다. 
자바스크립트가 이해하는 어떤 값도 저장이 가능하며, 비동기적으로 동작하는 특이점을 가지고 있다.


