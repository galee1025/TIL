# 1125) REST API

```
💡 REST의 제약을 준수했다는 의미로 이해하기! 쉽고 사용하기 쉬운 API를 만드는 것이 목적이다
```

- REST란 REpresentational State Transfer의 약자로 API 작동 방식에 조건을 부과하는 <br>소프트웨어 아키텍처(제약 조건의 집합)를 말한다.
- 자원, 행위, 표현으로 세 가지로 구성되어 있고 URI, HTTP Method, 자원에 대한 응답을 뜻한다.
- URI를 이용해 정보의 자원을 표현하고, 자원에 대한 행위를 HTTP Method를 이용해 표현한다.

<br>
<br>

# 1126) Restful API와 GraphQL 차이점

- RESTful API는 URI, HTTP Method를 조합하기 때문에 다양한 엔드포인트가 존재하는 반면, GQL은 하나의 엔드포인트만 존재한다.
- REST에서는 자원의 크기와 형태를 서버에서 결정하지만, GQL에서는 자원에 대한 정보만 정의하고 필요한 크기와 형태는 요청 시 클라이언트가 결정한다.
- REST에서는 여러 자원에 접근할 때 여러 번의 요청이 필요하지만, GQL은 한 번의 요청으로 여러 자원에 접근 할 수 있다.
- RESTful API는 세트 메뉴, GraphQL은 뷔페

<br>
<br>

# 1127) SSR / CSR
 
```
💡 SSR : 클라이언트(브라우저)가 서버에 데이터를 요청해 서버에서 렌더링을 처리하는 방식
```

- 첫 페이지 로딩 속도가 CSR에 비해 빠르다 : 첫 페이지에 해당하는 문서만 브라우저에 전달해 렌더링하기 때문
- SEO(검색 엔진 최적화)에 유리 : 이해 필요
- 초기 로딩 이후 페이지 이동 시 속도가 다소 느림 : 페이지 이동시 마다 서버에 데이터 요청, 응답하다보니 속도가 다소 느림
<br>

```
💡 CSR : 클라이언트(브라우저)가 렌더링을 처리하는 방식
```

- 빠른 인터렉션 : 렌더링을 브라우저에게 담당시킴으로서 서버 트래픽 감소
- 새로고침을 하지 않음 : 페이지 이동 시 html 변화가 없고, JavaScript로 그려진다.
- 첫 페이지 로딩 속도가 SSR에 비해 다소 느림
- SEO(검색 엔진 최적화)에 불리

<br>
<br>

# 1128) HTTP

```
💡 텍스트 기반의 통신 규약으로 인터넷 상에서 데이터를 주고 받기 위해 서버/클라이언트 모델을 따르는 프로토콜이다
```

### 특징으로는,
TCP/IP 위에서 동작하는 응용 프로그램이고, 
비연결성, 무상태 프로토콜이며, 요청/응답 방식으로 동작한다.
<br>

### 비연결성 프로토콜이란,
클라이언트의 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 것.<br>
다수의 유저가 웹 서비스를 이용하더라도 접속 유지를 최소한으로 할 수 있다.
<br>

### 무상태란,
HTTP의 비연결성으로 인해 연결이 해제됨과 동시에 서버가 이전의 요청 결과를 잊어버리게 된다.<br>
똑같은 데이터를 원한다하더라도 요청을 동일하게 해야한다. 서버의 부담을 줄여준다.
<br>

### 무상태면 로그인과 같은 인증은 어떻게 할까?
최초의 로그인 요청에서 쿠키를 통해 이전 결과를 저장 할 수 있다.
<br>

### 쿠키를 이용하면 보안에 취약하지 않을까?
그래서 세션이나 토큰을 이용해 보안을 강화한다
<br>

### Method 종류
- GET, POST, PUT, PATCH, **DELETE**, OPTIONS(preflight요청시 사용 → CORS 관련)
- 찜한 상품 페이지에서 삭제 버튼 기능에 이용했었다.

<br>
<br>

# 1129) 동기와 비동기

### 비동기 처리는 왜 할까?
많은 요청을 처리 할 때 빠르고 효율적이기 때문이다.
처리 결과에 의존하지 않고 성능적으로 빠른 처리가 가능하다.
<br>

### 비동기 함수를 동기 함수로 만드는 방법을 아는가? 다른 방법은?
**callback, Promise, async/await**

<br>

# 1130) Why React?

### jQuery나 다른 툴도 많은데 왜 리액트를 선택해야 할까?
- 가상DOM을 이용해 동적 페이지를 빠르고 효율적으로 구성할 수 있음
- 컴포넌트로 재사용이 가능하고, 복잡한 UI를 구성할 수 있으며 유지보수에 용이
- 테스트 친화적
- 광범위한 커뮤니티
<br>

### 리액트가 다른 프레임워크랑 다른 점, 장단점
- 라이브러리, 작고 가볍다
- third-party 라이브러리를 통해 다양한 기능 추가 가능
- 커뮤니티가 가장 크고, 활성화 되어 있다

<br>
<br>

# 1201) SPA

```
💡 Single Page Application : 하나의 html 페이지로 구성된 애플리케이션
```

페이지 이동 시 자바스크립트를 이용해 DOM 구조를 바꿔 렌더링 하는 방식으로 페이지 렌더링을 클라이언트 쪽에서 한다.
React, Vue, Angular는 SPA 기능을 제공한다.
<br>

### 장점
- 페이지 갱신 시 필요한 데이터만 요청, 서버 트래픽이 감소한다.
- 변경 부분만 리렌더링 하는 방식으로 사용자 경험 면에서 SSR보다 유리하다.
<br>

### 단점
- CSR 방식으로 SEO에 불리하다.
- 초기 구동속도가 느리다.
- 데이터 처리가 클라이언트에서 이뤄지기 때문에(쿠키) 보안 이슈가 있다.
<br>

### 단점 보완
- SEO를 보완할 수 있는 프레임워크나 라이브러리 사용
- webpack의 code splitting(코드 분할)으로 초기 구동 속도 해결
  ![https://miro.medium.com/max/1100/0*XFWjCMxz7wLnDDMl.webp](https://miro.medium.com/max/1100/0*XFWjCMxz7wLnDDMl.webp)
   
   전체 코드 양을 줄이지 않고 사용자가 필요하지 않은 코드를 로드하는 것을 피하고, 초기 페이지 로드 시 필요한 코드만 받게 된다.
- 비즈니스 로직은 서버에서 수행

<br>
<br>

# 1204) DOM, Virtual DOM

### Document Object Model
```
💡 웹 페이지를 구성하는 요소를 구조화 해 나타낸 객체.
이 객체를 이용해 웹 페이지 구성 요소를 제어 할 수 있다.
(html 요소들의 구조화 된 표현)
```

브라우저에서 DOM에 변화가 일어나면 브라우저는 CSS를 다시 연산하고, 레이아웃을 연산하고, 구성하고, 페이지를 리페인트 한다.<br>
이런 반복되는 불필요하고 비효율적인 연산 등의 문제 해결을 위해 virtual DOM 방식이 등장했다.

<br>

### Virtual Document Object Model

```
💡DOM을 추상화 한 객체, 최적의 자원을 사용해 업데이트 할 수 있다.
```

render 함수가 반환하는 결과를 virtual DOM에 렌더링 한 후
이전 상태와 현재 상태를 비교해 최소한의 연산을 이용해 바뀐 부분만 실제 DOM에 적용한다.

<br>
<br>

# 1205) React 컴포넌트

### 컴포넌트란
리액트에서의 컴포넌트는 **독립적이고 재사용이 가능한 코드 조각으로 구성**되어 있다. 
자바스크립트 함수와 동일한 목적을 수행하지만 **독립적으로 작동하고 HTML을 반환**한다. 데이터를 받아 뷰 상태를 관리해 DOM node를 출력한다.
컴포넌트 작성 방법에는 클래스 컴포넌트와 함수형 컴포넌트 두 가지 타입이 존재한다.

<br>

### 클래스 컴포넌트와 함수형 컴포넌트의 차이?
두 컴포넌트의 역할은 동일하다. 차이점이 있다면 클래스형은 state 객체로 상태 관리 및 라이프 사이클 기능을 사용 할 수 있으며 임의 메서드를 정의 할 수 있다. render() 함수 내에서 jsx를 반환 한다.
반면, 함수형 컴포넌트는 선언하기가 클래스 컴포넌트에 비해 편하고, 메모리 자원을 덜 사용한다는 장점이 있다. 과거에는 상태 관리와 라이프 사이클 API를 사용 할 수 없었지만, Reack hook의 도입으로 **현재는 공식문서에서 함수형 컴포넌트와 훅을 함께 사용할 것을 권장**하고 있다.

<br>

### 재사용 가능한 컴포넌트
재사용성이 좋은 컴포넌트의 조건
1. 비즈니스 로직이 없고
2. 상태값이 없다 (마우스 오버 같은 ui 효과 상태값은 제외)

매개변수(props)를 이용해 하나의 컴포넌트로 구조를 유지하며 다른 값을 렌더링 할 수 있다. 
<CLASS IOI> 프로젝트 당시 모달 컴포넌트를 재사용해 댓글 추가/수정 할 수 있도록 구현했다.

<br>
<br>

# 1206) 이벤트 버블링과 위임
  
부모 요소를 가지고 있는 요소에서 이벤트가 발생했을 때 브라우저는 두가지 단계를 실행한다. 캡처링 단계 → 버블링 단계

### 이벤트 버블링 : 하위 이벤트가 상위로 전달되는 흐름
한 요소에서 이벤트가 발생하면 제일 깊은 곳에 위치한 요소에서 시작, 부모 요소를 거슬러 올라가 가장 최상단의 조상 요소까지 해당 요소들의 핸들러가 동작한다. 
이 모양을 물 속 거품과 닮았다고 해서 ‘이벤트 버블링’이라고 부른다.

<br>
  
### 이벤트 캡처링 : 이벤트가 발생한 지점을 찾아 상위에서 하위로 전달되는 흐름
버블링과 반대로 작동. 이벤트가 최상위 조상(html)에서 시작해 아래로 전파되는 흐름, 실제 코드에서는 자주 쓰이진 않는다. 
`addEventListener` 의 `capture` 옵션을 `true`로 설정하면 캡처링 단계에서 이벤트를 잡아낼 수 있다. (기본값이 `false`)

<br>

### 표준 DOM 이벤트에서 정의한 이벤트 흐름 3단계
1. **캡처링** - 이벤트가 하위 요소로 전파되는 단계
2. **타깃** - 이벤트가 실제 타깃 요소에 전달되는 단계
3. **버블링** - 이벤트가 상위 요소로 전파되는 단계

<br>

### 이벤트 위임
이벤트 버블링과 캡처링을 이용해 비슷한 방식으로 여러 요소 이벤트를 다룰 때 사용된다. 
요소마다 핸들러를 할당하지 않고, 요소의 공통 조상에 이벤트 핸들러 하나만 할당해도 여러 요소를 한 번에 다룰 수 있다.
